import { ɵɵdefineInjectable, Injectable, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Input, Pipe, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { DomSanitizer } from '@angular/platform-browser';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/platform-browser';

function NgxSpinnerComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxSpinnerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtemplate(1, NgxSpinnerComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r0.spinner.bdColor)("z-index", ctx_r0.spinner.zIndex)("position", ctx_r0.spinner.fullScreen ? "fixed" : "absolute")("color", ctx_r0.spinner.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function NgxSpinnerComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function NgxSpinnerComponent_ng_template_2_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9)(1, "span", 10);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.spinner.class);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.loadingText);
} }
function NgxSpinnerComponent_ng_template_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 11);
    ɵngcc0.ɵɵpipe(1, "safeHtml");
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("innerHTML", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r6.loaderTemplate), ɵngcc0.ɵɵsanitizeHtml);
} }
const _c0 = function (a0, a1) { return { "sr-only": a0, "loading-text": a1 }; };
function NgxSpinnerComponent_ng_template_2_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(2, _c0, ctx_r7.isButtonSpinner, !ctx_r7.isButtonSpinner));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.loadingText, " ");
} }
function NgxSpinnerComponent_ng_template_2_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 11);
    ɵngcc0.ɵɵpipe(1, "safeHtml");
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("innerHTML", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r8.loadingTextTemplate), ɵngcc0.ɵɵsanitizeHtml);
} }
function NgxSpinnerComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgxSpinnerComponent_ng_template_2_span_0_Template, 3, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(1, NgxSpinnerComponent_ng_template_2_div_1_Template, 2, 3, "div", 7);
    ɵngcc0.ɵɵtemplate(2, NgxSpinnerComponent_ng_template_2_div_2_Template, 2, 5, "div", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵtemplate(4, NgxSpinnerComponent_ng_template_2_div_4_Template, 2, 3, "div", 7);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.loaderTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.loaderTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.loadingTextTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.isButtonSpinner && !ctx_r3.loadingTextTemplate ? ctx_r3.loadingText : "", " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.loadingTextTemplate);
} }
const DEFAULTS = {
    BD_COLOR: 'rgba(51,51,51,0.8)',
    SPINNER_COLOR: '#fff',
    SPINNER_TYPE: 'border',
    Z_INDEX: 99999,
};
const PRIMARY_SPINNER = 'primary';
class NgxSpinner {
    constructor(init) {
        Object.assign(this, init);
    }
}

class NgxSpinnerService {
    /**
     * Creates an instance of NgxSpinnerService.
     * @memberof NgxSpinnerService
     */
    constructor() {
        /**
         * Spinner observable
         *
         * @memberof NgxSpinnerService
         */
        // private spinnerObservable = new ReplaySubject<NgxSpinner>(1);
        this.spinnerObservable = new BehaviorSubject(null);
    }
    /**
    * Get subscription of desired spinner
    * @memberof NgxSpinnerService
    **/
    getSpinner(name) {
        return this.spinnerObservable.asObservable().pipe(filter((x) => x && x.name === name));
    }
    /**
     * To show spinner
     *
     * @memberof NgxSpinnerService
     */
    show(name = PRIMARY_SPINNER, spinner) {
        setTimeout(() => {
            const showPromise = new Promise((resolve, _reject) => {
                if (spinner && Object.keys(spinner).length) {
                    spinner['name'] = name;
                    this.spinnerObservable.next(new NgxSpinner(Object.assign(Object.assign({}, spinner), { show: true })));
                    resolve(true);
                }
                else {
                    this.spinnerObservable.next(new NgxSpinner({ name, show: true }));
                    resolve(true);
                }
            });
            return showPromise;
        }, 10);
    }
    /**
    * To hide spinner
    *
    * @memberof NgxSpinnerService
    */
    hide(name = PRIMARY_SPINNER, debounce = 10) {
        setTimeout(() => {
            const hidePromise = new Promise((resolve, _reject) => {
                this.spinnerObservable.next(new NgxSpinner({ name, show: false }));
                resolve(true);
            });
            return hidePromise;
        }, debounce);
    }
}
NgxSpinnerService.ɵfac = function NgxSpinnerService_Factory(t) { return new (t || NgxSpinnerService)(); };
NgxSpinnerService.ɵprov = ɵɵdefineInjectable({ factory: function NgxSpinnerService_Factory() { return new NgxSpinnerService(); }, token: NgxSpinnerService, providedIn: "root" });
NgxSpinnerService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSpinnerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

// import { trigger, state, style, transition, animate } from '@angular/animations';
class NgxSpinnerComponent {
    /**
     * Creates an instance of NgxSpinnerComponent.
     *
     * @memberof NgxSpinnerComponent
     */
    constructor(spinnerService, changeDetector, elementRef) {
        this.spinnerService = spinnerService;
        this.changeDetector = changeDetector;
        this.elementRef = elementRef;
        /**
         * button Spinner.
         * https://getbootstrap.com/docs/4.4/components/spinners/#buttons
         *
         * @memberof NgxSpinnerComponent
         *
         */
        this.isButtonSpinner = false;
        /**
         * isButtonSpinner is true and when the spinner shown,the button disabled set to true
         *
         * @memberof NgxSpinnerComponent
         *
         */
        this.autoDisableButton = false;
        /**
         * Spinner Object
         *
         * @memberof NgxSpinnerComponent
         */
        this.spinner = new NgxSpinner();
        /**
         * Unsubscribe from spinner's observable
         *
         * @memberof NgxSpinnerComponent
        **/
        this.ngUnsubscribe = new Subject();
        /**
         * To set default ngx-spinner options
         *
         * @memberof NgxSpinnerComponent
         */
        this.setDefaultOptions = () => {
            this.spinner = new NgxSpinner({
                name: this.name,
                bdColor: this.bdColor,
                size: this.size,
                color: this.color,
                type: this.type,
                fullScreen: this.fullScreen,
                show: this.show,
                zIndex: this.zIndex,
                loaderTemplate: this.loaderTemplate,
                loadingTextTemplate: this.loadingTextTemplate,
                autoDisableButton: this.autoDisableButton
            });
        };
        this.bdColor = DEFAULTS.BD_COLOR;
        this.zIndex = DEFAULTS.Z_INDEX;
        this.color = DEFAULTS.SPINNER_COLOR;
        this.type = DEFAULTS.SPINNER_TYPE;
        this.size = 'default';
        this.fullScreen = true;
        this.name = PRIMARY_SPINNER;
        this.loaderTemplate = null;
        this.show = false;
    }
    /**
     * Initialization method
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnInit() {
        this.setDefaultOptions();
        this.spinnerService.getSpinner(this.name).subscribe(x => {
            if (this.isButtonSpinner && this.autoDisableButton) {
                let button = this.elementRef.nativeElement.closest("button");
                button.disabled = x.show;
            }
        });
        this.spinnerService.getSpinner(this.name)
            .pipe(takeUntil(this.ngUnsubscribe))
            .subscribe((spinner) => {
            this.setDefaultOptions();
            Object.assign(this.spinner, spinner);
            if (spinner.show) {
                this.onInputChange();
            }
            this.changeDetector.markForCheck();
        });
    }
    /**
     * On changes event for input variables
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnChanges(changes) {
        for (const propName in changes) {
            if (propName) {
                const changedProp = changes[propName];
                if (changedProp.isFirstChange()) {
                    return;
                }
                else if (typeof changedProp.currentValue !== 'undefined' && changedProp.currentValue !== changedProp.previousValue) {
                    if (changedProp.currentValue !== '') {
                        this.spinner[propName] = changedProp.currentValue;
                    }
                }
            }
        }
    }
    /**
     * To get class for spinner
     *
     * @memberof NgxSpinnerComponent
     */
    getClass(type, size) {
        let sizeClass = '';
        switch (size.toLowerCase()) {
            case 'small':
                sizeClass = 'sm';
                break;
            default:
                break;
        }
        if (sizeClass == '')
            return ['spinner-' + type];
        else
            return ['spinner-' + type, 'spinner-' + type + '-' + sizeClass];
    }
    /**
     * Check if input variables have changed
     *
     * @memberof NgxSpinnerComponent
     */
    onInputChange() {
        this.spinner.class = this.getClass(this.spinner.type, this.spinner.size);
    }
    /**
     * Component destroy event
     *
     * @memberof NgxSpinnerComponent
     */
    ngOnDestroy() {
        this.ngUnsubscribe.next();
        this.ngUnsubscribe.complete();
    }
}
NgxSpinnerComponent.ɵfac = function NgxSpinnerComponent_Factory(t) { return new (t || NgxSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(NgxSpinnerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxSpinnerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxSpinnerComponent, selectors: [["ngx-bootstrap-spinner"]], inputs: { isButtonSpinner: "isButtonSpinner", autoDisableButton: "autoDisableButton", bdColor: "bdColor", zIndex: "zIndex", color: "color", type: "type", size: "size", fullScreen: "fullScreen", name: "name", loaderTemplate: "loaderTemplate", loadingText: "loadingText", loadingTextTemplate: "loadingTextTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 2, consts: [["class", "overlay d-flex flex-column justify-content-center align-items-center", 3, "background-color", "z-index", "position", "color", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf"], ["loadingTemplate", ""], [1, "overlay", "d-flex", "flex-column", "justify-content-center", "align-items-center"], [4, "ngTemplateOutlet"], [3, "ngTemplateOutlet"], ["role", "status", "aria-hidden", "true", 3, "ngClass", 4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["role", "status", "aria-hidden", "true", 3, "ngClass"], [1, "sr-only"], [3, "innerHTML"], [3, "ngClass"]], template: function NgxSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxSpinnerComponent_div_0_Template, 2, 9, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NgxSpinnerComponent_ng_container_1_Template, 1, 1, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, NgxSpinnerComponent_ng_template_2_Template, 5, 5, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isButtonSpinner && ctx.spinner.show);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isButtonSpinner && ctx.spinner.show);
    } }, dependencies: function () { return [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, SafeHtmlPipe]; }, styles: [".overlay[_ngcontent-%COMP%]{height:100%;left:0;position:fixed;top:0;width:100%}"], changeDetection: 0 });
NgxSpinnerComponent.ctorParameters = () => [
    { type: NgxSpinnerService },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NgxSpinnerComponent.propDecorators = {
    bdColor: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    fullScreen: [{ type: Input }],
    name: [{ type: Input }],
    zIndex: [{ type: Input }],
    loaderTemplate: [{ type: Input }],
    loadingText: [{ type: Input }],
    loadingTextTemplate: [{ type: Input }],
    isButtonSpinner: [{ type: Input }],
    autoDisableButton: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSpinnerComponent, [{
        type: Component,
        args: [{ selector: 'ngx-bootstrap-spinner', template: "<div *ngIf=\"!isButtonSpinner&&spinner.show\"\r\n  class=\"overlay d-flex flex-column justify-content-center align-items-center\"\r\n  [style.background-color]=\"spinner.bdColor\" [style.z-index]=\"spinner.zIndex\"\r\n  [style.position]=\"spinner.fullScreen ? 'fixed' : 'absolute'\" [style.color]=\"spinner.color\">\r\n  <ng-container *ngTemplateOutlet=\"loadingTemplate\"></ng-container>\r\n</div>\r\n\r\n<ng-container *ngIf=\"isButtonSpinner&&spinner.show\" [ngTemplateOutlet]=\"loadingTemplate\">\r\n</ng-container>\r\n\r\n<ng-template #loadingTemplate>\r\n  <span *ngIf=\"!loaderTemplate\" [ngClass]=\"spinner.class\" role=\"status\" aria-hidden=\"true\">\r\n    <span class=\"sr-only\">{{loadingText}}</span>\r\n  </span>\r\n  <div *ngIf=\"loaderTemplate\" [innerHTML]=\"loaderTemplate | safeHtml\"></div>\r\n  <div *ngIf=\"!loadingTextTemplate\" [ngClass]=\"{'sr-only': isButtonSpinner,'loading-text':!isButtonSpinner}\">\r\n    {{loadingText}}\r\n  </div>\r\n  {{isButtonSpinner&&!loadingTextTemplate?loadingText:\"\"}}\r\n  <div *ngIf=\"loadingTextTemplate\" [innerHTML]=\"loadingTextTemplate | safeHtml\"></div>\r\n</ng-template>\r\n", changeDetection: ChangeDetectionStrategy.OnPush, styles: [".overlay{height:100%;left:0;position:fixed;top:0;width:100%}"] }]
    }], function () { return [{ type: NgxSpinnerService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { isButtonSpinner: [{
            type: Input
        }], autoDisableButton: [{
            type: Input
        }], bdColor: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], color: [{
            type: Input
        }], type: [{
            type: Input
        }], size: [{
            type: Input
        }], fullScreen: [{
            type: Input
        }], name: [{
            type: Input
        }], loaderTemplate: [{
            type: Input
        }], loadingText: [{
            type: Input
        }], loadingTextTemplate: [{
            type: Input
        }] }); })();

class SafeHtmlPipe {
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    transform(v) {
        if (v) {
            return this._sanitizer.bypassSecurityTrustHtml(v);
        }
    }
}
SafeHtmlPipe.ɵfac = function SafeHtmlPipe_Factory(t) { return new (t || SafeHtmlPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DomSanitizer, 16)); };
SafeHtmlPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "safeHtml", type: SafeHtmlPipe, pure: true });
SafeHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SafeHtmlPipe, [{
        type: Pipe,
        args: [{
                name: 'safeHtml'
            }]
    }], function () { return [{ type: ɵngcc2.DomSanitizer }]; }, null); })();

class NgxSpinnerModule {
}
NgxSpinnerModule.ɵfac = function NgxSpinnerModule_Factory(t) { return new (t || NgxSpinnerModule)(); };
NgxSpinnerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxSpinnerModule });
NgxSpinnerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSpinnerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [NgxSpinnerComponent, SafeHtmlPipe],
                exports: [NgxSpinnerComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSpinnerModule, { declarations: function () { return [NgxSpinnerComponent, SafeHtmlPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgxSpinnerComponent]; } }); })();

/*
 * Public API Surface of ngx-bootstrap-spinner
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSpinnerComponent, NgxSpinnerModule, NgxSpinnerService, SafeHtmlPipe as ɵa };

//# sourceMappingURL=ngx-bootstrap-spinner.js.map